{$F+}
{$I OPDEFINE.INC}

UNIT PKTmain;

interface

uses
  OpDos,
  OpInline,
  OpString,
  OpRoot,
  OpCrt,
  OpColor,
  {$IFDEF UseMouse}
  OpMouse,
  {$ENDIF}
  OpFrame,
  OpCmd,
  OpWindow,
  OpMenu,
  wins,
  filing,
  misc,
  robot,
  robot2;

  {$IFDEF UseMouse}
const
  MouseChar : Char = #04;
  {$ENDIF}

{Color set used by menu system}
const
  MenuColors : ColorSet = (
    TextColor       : YellowOnBlue;       TextMono        : LtGrayOnBlack;
    CtrlColor       : YellowOnBlue;       CtrlMono        : WhiteOnBlack;
    FrameColor      : CyanOnBlue;         FrameMono       : LtGrayOnBlack;
    HeaderColor     : WhiteOnCyan;        HeaderMono      : BlackOnLtGray;
    ShadowColor     : DkGrayOnBlack;      ShadowMono      : WhiteOnBlack;
    HighlightColor  : WhiteOnRed;         HighlightMono   : BlackOnLtGray;
    PromptColor     : BlackOnCyan;        PromptMono      : LtGrayOnBlack;
    SelPromptColor  : BlackOnCyan;        SelPromptMono   : LtGrayOnBlack;
    ProPromptColor  : BlackOnCyan;        ProPromptMono   : LtGrayOnBlack;
    FieldColor      : YellowOnBlue;       FieldMono       : LtGrayOnBlack;
    SelFieldColor   : BlueOnCyan;         SelFieldMono    : WhiteOnBlack;
    ProFieldColor   : LtGrayOnBlue;       ProFieldMono    : LtGrayOnBlack;
    ScrollBarColor  : CyanOnBlue;         ScrollBarMono   : LtGrayOnBlack;
    SliderColor     : CyanOnBlue;         SliderMono      : WhiteOnBlack;
    HotSpotColor    : BlackOnCyan;        HotSpotMono     : BlackOnLtGray;
    BlockColor      : YellowOnCyan;       BlockMono       : WhiteOnBlack;
    MarkerColor     : WhiteOnMagenta;     MarkerMono      : BlackOnLtGray;
    DelimColor      : BlueOnCyan;         DelimMono       : WhiteOnBlack;
    SelDelimColor   : BlueOnCyan;         SelDelimMono    : WhiteOnBlack;
    ProDelimColor   : BlueOnCyan;         ProDelimMono    : WhiteOnBlack;
    SelItemColor    : YellowOnCyan;       SelItemMono     : BlackOnLtGray;
    ProItemColor    : LtGrayOnBlue;       ProItemMono     : LtGrayOnBlack;
    HighItemColor   : WhiteOnBlue;        HighItemMono    : WhiteOnBlue;
    AltItemColor    : WhiteOnBlue;        AltItemMono     : WhiteOnBlack;
    AltSelItemColor : WhiteOnCyan;        AltSelItemMono  : BlackOnLtGray;
    FlexAHelpColor  : WhiteOnBlue;        FlexAHelpMono   : WhiteOnBlack;
    FlexBHelpColor  : WhiteOnBlue;        FlexBHelpMono   : WhiteOnBlack;
    FlexCHelpColor  : LtCyanOnBlue;       FlexCHelpMono   : BlackOnLtGray;
    UnselXrefColor  : YellowOnBlue;       UnselXrefMono   : LtBlueOnBlack;
    SelXrefColor    : WhiteOnMagenta;     SelXrefMono     : BlackOnLtGray;
    MouseColor      : WhiteOnRed;         MouseMono       : BlackOnLtGray
  );

{Menu item constants}
const
  miWrite1        = 1;
  miEdit2         = 2;
  miRun3          = 3;
  miDelete4       = 4;
  miMove5         = 5;
  miUTIL6         = 6;
  miTranslate8    = 8;
  miDirectory9    = 9;
  miDos10         = 10;
  miExit7         = 7;



  {Menu item constants for menu in Revise}

  var
    status : word;
    M      : Menu;      {menu system}
    NewP   : string;

procedure ErrorHandler(UnitCode : Byte; var ErrCode : Word; Msg : string);
procedure DisplayHelp(UnitCode : Byte; IdPtr : Pointer; HelpIndex : Word);
procedure CustomizeItemString(var Name : String; Key : LongInt;
                              Selected, Highlighted : Boolean;
                              WPtr : RawWindowPtr);
function InitMenu(var M : Menu) : Word;

procedure pktmenu;


implementation

{$F+}
procedure ErrorHandler;
  {-Report errors}
begin
  RingBell;
end;

procedure DisplayHelp;
  {-Display context sensitive help}
begin
end;

procedure CustomizeItemString;
  {-Customize menu item strings}
begin
end;
{$F-}

function InitMenu;
  {-Initialize menu system generated by MAKEMENU}
const
  {Frame constants}
  Frame1 = 'ÕÔ¸¾ÍÍ³³';
begin
  with M do begin
    if not InitCustom(27, 10, 53, 16, MenuColors,
                      wBordered+wClear+wSaveContents,
                      Vertical) then begin
      InitMenu := InitStatus;
      Exit;
    end;
    mnOptionsOn(mnAlphaMatch+mnSelectOnClick+mnArrowSelect+mnAllHotSpots);
    mnOptionsOff(mnAllowPending+mnUseItemForTopic+mnSelectOnMatch+mnPopOnSelect);
    wFrame.SetFrameType(Frame1);
    AddShadow(shBR, shSeeThru);
    wFrame.AddHeader(' Main Menu ', heTC);
    AddItem('Write a new program', 1, 1, miWrite1);
    AddItem('Edit a program', 2, 1, miEdit2);
    AddItem('Run a Program', 3, 1, miRun3);
    AddItem('Delete a program', 4, 1, miDelete4);
    if MouseInstalled then
      AddItem('Move robot using mouse', 5, 1, miMove5)
    else AddItem('Move robot using keyboard', 5, 1, miMove5);
    AddItem('Utilities', 6, 1, miUTIL6);
      AddFramedSubMenu(42, 17, 75, 19, Vertical, Frame1);
      AddShadow(shBR, shSeeThru);
      AddItem('Translate PK-TEACH file to ASCII', 1, 1, miTranslate8);
      AddItem('Directory of programs', 2, 1, miDirectory9);
      AddItem('Exit to Dos', 3, 1, miDos10);
      ItemsDone;
    AddItem('Exit PK-TEACH', 7, 2, miExit7);
    ItemsDone;
    SetErrorProc(ErrorHandler);
    MenuCommands.SetHelpProc(DisplayHelp);
    SetCustomStringProc(CustomizeItemString);

    InitMenu := GetLastError;
  end;
end;

 procedure PKTmenu;

begin

  ClrScr;
  Status := InitMenu(M);
  if Status <> 0 then begin
    WriteLn('Error initializing menu: ', Status);
    Halt(1);
  end;

  {$IFDEF UseMouse}
  if MouseInstalled then
    with MenuColors do begin
      {activate mouse cursor}
      SoftMouseCursor($0000, (ColorMono(MouseColor, MouseMono) shl 8)+
                             Byte(MouseChar));
      ShowMouse;
      {enable mouse support}
      MenuCommands.cpOptionsOn(cpEnableMouse);
    end;
  {$ENDIF}
  NewP:= 'Enter "EXIT" to return to PK-TEACH'^M^J+GetEnvironmentString('Prompt');
  win[1]^.wFrame.AddHeader(' PK-Teach Robot Programming Instructor ',heTC);
  win[1]^.Draw;

  repeat
(*    win[1]^.Select;*)
    M.Select;
    M.Process;
    M.Erase;
    if M.GetLastCommand = ccSelect then
      case M.MenuChoice of

        miWrite1        : begin
                            robot_mode := write_new;
                            revise;
                          end;

        miEdit2         : begin
                            robot_mode := edit_prog;
                            revise;
                          end;

        miRun3          : exeprog;


        miDelete4       : begin
                            MenuCommands.cpOptionsOff(cpEnableMouse);
                            delprog;
                            MenuCommands.cpOptionsOn(cpEnableMouse);
                          end;


        miMove5         : begin
                            robot_mode := move_only;
                            revise;
                          end;

        miTranslate8    : pktoasc;

        miDirectory9    : dosdirwn;

        miDos10         : begin
                            win[shellwin]^.draw;
                            Status := ShellWithPrompt(NewP, NoExecDosProc);
                            if status <> 0
                            then begin
                              writeln;
                              writeln('Status from ShellWithPrompt in PKTMAIN is: ',status);
                              writeln;
                              delay(5000);
                            end;
                            win[shellwin]^.erase;
                          end;
        miExit7         : begin
                            if pkexit = true then
                              Status := ccQuit;
                          end;

        else begin
          gotoxy(1,1);
          clreol;
          write('Last command = ',M.GetLastCommand,'  and menu choice = ',
                M.MenuChoice);
          delay(5000);
        end;


      end; {Case}
    until Status = ccQuit;

    FullMouseWindow;

    {$IFDEF UseMouse}
    HideMouse;
    {$ENDIF}
    M.Done;
    win[1]^.Done;
 end;

begin
end.